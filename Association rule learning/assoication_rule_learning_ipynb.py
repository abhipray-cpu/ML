# -*- coding: utf-8 -*-
"""Assoication Rule Learning ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kk9XYMrl4qmH6BpNq8z07O0EQSdt85lT

#This notebook contains all the tools I will be using for association Rule learning projects:
"""

#importing libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

#importing the dataset
def generate_data(location:str,sample_number=10):
  data=pd.read_csv(location,engine='python')
  head=data.head()
  tail=data.tail()
  sample=data.sample(sample_number)
  description=data.describe()
  columns=data.columns
  info=data.info()
  shape=data.shape
  size=data.size
  return {'data':data,'head':head,'tail':tail,'sample':sample,'description':description,'columns':columns,'info':info,
          'shape':shape,'size':size}

data_set1 = generate_data('/content/Market_Basket_Optimisation.csv')

data1 = data_set1['data']

#Analyzing the data
data_set1['head']

data_set1['tail']

data_set1['description']

data1.shape

#we need to project our dataset into a particular format
#this function will project our dataset into the required format
def project(data):
  transactions=[]
  rows,columns=data.shape
  # we need to include one extra value then the number of rows
  for i in range (0,rows):
    transactions.append([str(data.values[i,j]) for j in range(0, columns)])
  #this will give the required format with which we can continue now
  #there will be a total of rows entries each containing the entire rows of the dataset
  return transactions

transactions = project(data1)

#chechking the new format dataset
for val in transactions:
  print(val)

#installing the module
!pip install apyori

#building the apriori model
def apriori(transactions,min_support:float,min_confidence:float=0.8,min_lift:int =3,min_length:int=2,max_length:int=2):
  from apyori import apriori
  rules = apriori(transactions = transactions, min_support = min_support, min_confidence = min_confidence, min_lift = min_lift, min_length = min_length, max_length = max_length)
  return rules
# we need to define the following parametres
#1)min_support:let's say we want to consider only those products that appear in atlest 3 transactions in a say 
#ans since this dataset contains the data of an entire week we will multiplt  3 with 7
# so our min support is (3*7)/Number of entrires in our dataset i.e transactions over the week
#therfore min_support  = (3*21)/7500


#2)min_confidence:Some rule of thumbs (start with 0.8 and then keep decreasing the confidence by dividing with 2
#i.e 0.8,0.4,0.2 and so on)
#3)min_lift: rule of thum start with 3 and then keep on Increasing the value based on your dataset
#4)min_confidence:min numbe of elements we want in our rules
#5)max_confidence max number of elements we want in our rule

#before calling the function let's define some functions and run a loop for getting different values:
min_support=[(3*7)/7500,(4*7)/7500,(5*7)/7500,(6*7)/7500] # item should apper atleast 3,4,5,6 times in transcations done in a day
min_confidence=[0.8,0.4,0.2]#starting with 0.8 and then decreasing the value each time
min_lift=[3,4,5,6,7,8,9] #starting with 3 and increasing the value consecutively
length=[2,3,4] # will use the same value for both min_length and max_length
#you can try with all these possible values
rules =  apriori(transactions,(3*7)/7500,0.2,3,2,2)
display_Aprori(rules)

rules =  apriori(transactions,(3*7)/7500,0.2,3,2,2)
display_Eclat(rules)

#installing the library
!pip install fpgrowth-py

#this function deduces the rules based on the FP tree approach
def FP_Growth(transactions,min_support,min_confidence):
  from fpgrowth_py import fpgrowth
  freqItemSet, rules = fpgrowth(transactions, minSupRatio=min_support, minConf=min_confidence)
  return {'frequentItemSets':freqItemSet,'rules':rules}

#now how to find the optimal value for min_support and min_confidence
#trying with a set of differnt values

min_support=[(3*7)/7500,(4*7)/7500,(5*7)/7500,(6*7)/7500] # item should apper atleast 3,4,5,6 times in transcations done in a day
min_confidence=[0.8,0.4,0.2]#starting with 0.8 and then decreasing the value each time
rulesFP=[] #this will be a list containing all the rules
valuesFP = [] #this will be coressponding values combination for the rules

for support in min_support:
  for confidence in min_confidence:
    rule = FP_Growth(transactions,support,confidence)
    rulesFP.append(rule)
    value = {'min_support':support,'min_confidence':confidence}
    valuesFP.append(value)

#this takes quite a long time to execute so execute at your own risk

#this funnction will display the rules for the apriori model
#this function takes a rule set as an argument
#this is fora rule set with two elements
def display_Aprori(rules,Rows:int=10):
  results = list(rules)
  if len(results) != 0:
    resultsinDataFrame = pd.DataFrame(inspect(results), columns = ['Left Hand Side', 'Right Hand Side', 'Support', 'Confidence', 'Lift'])
  # sorting the results in decreasing order based on the lift
    resultsinDataFrame=resultsinDataFrame.nlargest(n = Rows, columns = 'Lift')
    display(resultsinDataFrame)

#this block is hard coded and is specific for a rule set containig only two elements
def inspect(results):
    lhs         = [tuple(result[2][0][0])[0] for result in results]
    rhs         = [tuple(result[2][0][1])[0] for result in results]
    supports    = [result[1] for result in results]
    confidences = [result[2][0][2] for result in results]
    lifts       = [result[2][0][3] for result in results]
    return list(zip(lhs, rhs, supports, confidences, lifts))

#this funnction will display the rules for the eclat model
#this function takes a rule set as an argument
#this is also hard coded for a 2 item rule set
def display_Eclat(rules,Rows:int=10):
  results = list(rules)
  if len(results) != 0:
    resultsinDataFrame = pd.DataFrame(inspect(results), columns = ['Product 1', 'Product 2', 'Support'])
  # sorting the results in decreasing order based on the lift
    resultsinDataFrame=resultsinDataFrame.nlargest(n = Rows, columns = 'Support')
    display(resultsinDataFrame)

#this block is hard coded and is specific for a rule set containig only two elements
def inspect(results):
    lhs         = [tuple(result[2][0][0])[0] for result in results]
    rhs         = [tuple(result[2][0][1])[0] for result in results]
    supports    = [result[1] for result in results]
    return list(zip(lhs, rhs, supports))

#need to modify the result for more than two items rule sets

#this funnction will display the rules for the FP growth model
#this function takes a rule set as an argument
def display_FP(rules):
  pass

#test
test =  apriori(transactions,(3*7)/7500,0.2,3,4,4)

test=list(test)
testing = test[34]

display(testing)
display(testing[0])
display(testing[1])#this is the support value
display(testing[2])
display(testing[2][0])
display(testing[2][0][0]) #this is the set of two values associated with the 1 element
display(testing[2][0][1]) #this is the single associated value
display(testing[2][0][2])#this is the confidence value
display(testing[2][0][3])#this is the lift value


  #observations let's say we have a rule of n elements
  #than it signifies
  #that n-1 elements is associated with 1 element
#for eg if the rule set contains 3 elements that 2 of them will be a set which will be associated to the element in some way

#this funnction will display the rules for the apriori model
#this function takes a rule set as an argument
#this is fora rule set with three elements
def display_Aprori(rules,Rows:int=10):
  results = list(rules)
  if len(results) != 0:
    resultsinDataFrame = pd.DataFrame(inspect(results), columns = ['Left Hand Side', 'Right Hand Side', 'Support', 'Confidence', 'Lift'])
  # sorting the results in decreasing order based on the lift
    resultsinDataFrame=resultsinDataFrame.nlargest(n = Rows, columns = 'Lift')
    display(resultsinDataFrame)

#this block is hard coded and is specific for a rule set containig more than elements
def inspect(results):
    lhs         = [tuple(result[2][0][0])[0] for result in results]
    rhs         = [tuple(result[2][0][1])[0] for result in results]
    supports    = [result[1] for result in results]
    confidences = [result[2][0][2] for result in results]
    lifts       = [result[2][0][3] for result in results]
    return list(zip(lhs, rhs, supports, confidences, lifts))

#this funnction will display the rules for the eclat model
#this function takes a rule set as an argument
#this is also hard coded for more than 2 items rule set
def display_Eclat(rules,Rows:int=10):
  results = list(rules)
  if len(results) != 0:
    resultsinDataFrame = pd.DataFrame(inspect(results), columns = ['Product Set', 'Product', 'Support'])
  # sorting the results in decreasing order based on the lift
    resultsinDataFrame=resultsinDataFrame.nlargest(n = Rows, columns = 'Support')
    display(resultsinDataFrame)

#this block is hard coded and is specific for a rule set containig more than two elements
def inspect(results):
    lhs         = [tuple(result[2][0][0])[0] for result in results]
    rhs         = [tuple(result[2][0][1])[0] for result in results]
    supports    = [result[1] for result in results]
    return list(zip(lhs, rhs, supports))