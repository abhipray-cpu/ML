# -*- coding: utf-8 -*-
"""Clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12aanJ-BK1fsRriwesxB7sFydNROHlM_-

# ***This notebook contains all the tools I use for clustering machine learning problems***
"""

#importing libraries'
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import seaborn as sns
sns.set(style="darkgrid")

#importing the dataset
def generate_data(location:str,sample_number=10):
  data=pd.read_csv(location,engine='python')
  head=data.head()
  tail=data.tail()
  sample=data.sample(sample_number)
  description=data.describe()
  columns=data.columns
  info=data.info()
  shape=data.shape
  size=data.size
  return {'data':data,'head':head,'tail':tail,'sample':sample,'description':description,'columns':columns,'info':info,
          'shape':shape,'size':size}

data_set1=generate_data('/content/Air_Traffic_Passenger_Statistics.csv')
data_set2=generate_data('/content/total_data_na.csv')
data_set3=generate_data('/content/Mall_Customers.csv')
data_set4=generate_data('/content/CC GENERAL.csv')

data_set4=generate_data('/content/CC GENERAL.csv')
data4=data_set4['data']
data4=preprocess_data(data4)

data1=data_set1['data']
data2=data_set2['data']
data3=data_set3['data']
data4=data_set4['data']

#analyzing the data
data_set1['head']

data_set1['tail']

data_set2['head']

data_set2['tail']

data_set1['description']

data_set2['description']

data_set1['columns']

data_set2['columns']

data_set3['columns']

data_set3['head']

data_set3['description']

#analyzing the datasets via a heat map to tudy the correlation between the features
def create_heat_map(data):
  #correalation between varaibles
  plt.figure(figsize=(18, 15))
  heatmap = sns.heatmap(data.corr(), vmin=-1, vmax=1, annot=True, cmap='BrBG')
  heatmap.set_title('Correlation Heatmap', fontdict={'fontsize':18}, pad=12);
  # save heatmap as .png file
  # dpi - sets the resolution of the saved image in dots/inches
  # bbox_inches - when set to 'tight' - does not allow the labels to be cropped
  plt.savefig('heatmap.png', dpi=300, bbox_inches='tight')# this will will also return two dataset one being the original one and second one will be the one in

#heat map for first dataset
create_heat_map(data1)

#heat map for second dataset
create_heat_map(data2)
#since there are specific regions with high correlation density we can drop others if we want to

create_heat_map(data3)

create_data_map(data4)

#data preprocessing steps
def get_type(data):
  numeric=[]
  categorical=[]
  for col in data.columns:
    if data[f'{col}'].dtypes == 'object':
      categorical.append(col)
    else:
      numeric.append(col)
  return {'numeric':numeric,'categorical':categorical}

# check for null values and deal with them
# this function will take the type of process as well for both numeric and categorical data
def treat_null_values(data,numeric_type:str='mean'):
  types=get_type(data)
  numeric=types['numeric']
  categorical=types['categorical']
  if numeric_type == 'mean':
    for col in numeric:
      data[f'{col}']=data[f'{col}'].fillna(data[f'{col}'].mean())
  elif numeric_type == 'mode':
    for col in numeric:
      data[f'{col}']=data[f'{col}'].fillna(data[f'{col}'].mode())
  elif numeric_type == 'median':
    for col in numeric:
      data[f'{col}']=data[f'{col}'].fillna(data[f'{col}'].median())
  elif numeric_type == 'frequent':
    for col in numeric:
      data[f'{col}']=data[f'{col}'].fillna(data[f'{col}'].nunique[0])
  elif numeric_type == 'drop':
    for col in numeric:
      data[f'{col}']=data[f'{col}'].dropnna(inplace=True)
  elif numeric_type == 'predictive_modeling':
    pass # create a seprate function for this
  elif numeric_type == 'impute':
    pass # create a seprate function for this as well
  
  for col in categorical:
    most_frequent_category=data[f'{col}'].mode()[0]
    data[f'{col}'].fillna(most_frequent_category,inplace=True)
  return data

  

def predictive_modeling():
  pass #do a detailed study as disadvantages for this model usually outweights advantages
def multiple_imputation():
  from fancyimpute import IterativeImputer as MICE
  data= pd.DataFrame(MICE().fit_transform(data))
  return data

def encode_data(data,multiclass:str='One_hot',binary_class:str='Label'): #this function takes three args one is the data 2nd is the type of encoding for multiclass data and third is the encoding for binary class data
  categorical=get_type(data)['categorical']
  multivariate=[]
  bivariate=[]
  for col in categorical:
    if data[f'{col}'].nunique()>2:
      multivariate.append(col)
    else:
      bivariate.append(col)
  
  if multiclass == 'One_hot':
    for col in multivariate:
      data=encode_and_bind(data,col)
  if binary_class == 'Label':
    for col in bivariate:
      data=label_encode(data,col)
  # add other sorting techniques as well in here
  return data

def encode_and_bind(original_dataframe, feature_to_encode):
    dummies = pd.get_dummies(original_dataframe[[feature_to_encode]])
    res = pd.concat([original_dataframe, dummies], axis=1)
    res.pop(feature_to_encode)
    return(res)

def label_encode(data,col):
  from sklearn.preprocessing import LabelEncoder
  encoder=LabelEncoder()
  data[col]=encoder.fit_transform(data[col])
  return data
  
# this function needs to be modified therefore add differenr sort of encoding techniques as well in this cll

def treat_outliers(data,feature:str,algo:str='IQR',z_threshold:int=3,add_feature=None,remove:bool=False,scatter:bool=False,feature_x=None,feature_y=None): # this function takes two arguments one is data and 2ns is the algorithm
  pass
  if scatter == True:
    px.scatter(data,x=feature_x,y=feature_y,hover_name='Country')
  else:
    if algo == 'IQR':
      outlier_index=Inter_quantile_range(data,feature)
    if algo == 'EEA': # elliptic envelope algo
      outlier_index=Elliptice_envelope_algo(data,feature,add_feature)
    if algo == 'ISF': # Isolate forest algo
      outlier_index=Isolate_forest_algo(data,feature)
    if algo == 'One_classSVM': # one class svm
      outlier_index=One_class_SVM(data,feature)
    if algo == 'LOF':
      outlier_index=Local_factor_outlier(data,feature)
    if algo == 'Z_score':
      outlier_index=Z_score_algo(data,feature,z_threshold)
    print(outlier_index)
    if remove == True:
      data=remove_outliers(outlier_index,data)
    
    return data
    


# in all these function display the index of outliers

def Local_factor_outlier(data,feature):
  import numpy as np 
  from sklearn.neighbors import LocalOutlierFactor
  X=data[[feature,data.columns.values[-1]]]
  lof = LocalOutlierFactor(n_neighbors=20, algorithm='auto',
                         metric='minkowski', contamination=0.04,
                         novelty=False, n_jobs=-1)
  pred = lof.fit_predict(X)
  outlier_index = np.where(pred==-1)
  return outlier_index

def One_class_SVM(data,feature): #this returns novelty I am guessing so fuck this method
  import numpy as np
  from sklearn.svm import OneClassSVM
  X=data[[feature,data.columns.values[-1]]]
  one_class_svm = OneClassSVM(kernel='rbf', degree=3, gamma='scale')
  new_data = np.array([[-4, 8.5]])# change these values as per your dataset
  one_class_svm.fit(X)
  pred = one_class_svm.predict(new_data)
  outlier_index = np.where(pred==-1)
  return outlier_index

def Isolate_forest_algo(data,feature):
  import numpy as np
  from sklearn.ensemble import IsolationForest
  from sklearn.decomposition import PCA
  from sklearn.preprocessing import StandardScaler
  X=data[[feature,data.columns.values[-1]]]
   # Returns 1 of inliers, -1 for outliers
  iforest = IsolationForest(n_estimators=100, max_samples='auto', 
                          contamination=0.05, max_features=1.0, 
                          bootstrap=False, n_jobs=-1, random_state=1)
  pred = iforest.fit_predict(X)
 # Extract outliers
  outlier_index = np.where(pred==-1)
  return outlier_index

def Elliptice_envelope_algo(data,feature,add_feature):
  import numpy as np
  from sklearn.covariance import EllipticEnvelope
  elpenv = EllipticEnvelope(contamination=0.025, 
                          random_state=1)
  X=data[[feature,add_feature]]
# Returns 1 of inliers, -1 for outliers
  pred = elpenv.fit_predict(X)

# Extract outliers
  outlier_index = np.where(pred==-1)
  return outlier_index

def Inter_quantile_range(data,feature):
  Q1 = np.percentile(data[f'{feature}'], 25, interpolation = 'midpoint') 
  Q2 = np.percentile(data[f'{feature}'], 50, interpolation = 'midpoint') 
  Q3 = np.percentile(data[f'{feature}'], 75, interpolation = 'midpoint') 
  IQR = Q3 - Q1 
  low_lim = Q1 - 1.5 * IQR
  up_lim = Q3 + 1.5 * IQR
  outlier_index=[]
  for val in data[f'{feature}']:
    if val > up_lim or val <low_lim:
      outlier_index.append(data.index[data[f'{feature}'] == val].values[0])
  return outlier_index
         
def Z_score_algo(data,feature,z_threshold):
  mean = np.mean(data[f'{feature}'])
  std = np.std(data[f'{feature}'])
  print('mean of the dataset is', mean)
  print('std. deviation is', std)
  outlier_index = []
  for val in data[f'{feature}']:
    z = (val-mean)/std
    if z > z_threshold:
      outlier_index.append(data.index[data[f'{feature}'] == val].values[0])
  return outlier_index
  


# this function will remove the outliers if removal is allowed
def remove_outliers(index,data):
  for row in index:
    data.drop([row])
    print(f'dropped value at index {row}')
  return data

      

# if remove is true remove outliers else if it is false just return the index of outliers
# this will function will be returning two datasets the original one and one in which all the outliers are removed

#since we are not filtering for any dependent variable in the clustering therefore feature is not require
def preprocess_data(data):
  data=treat_null_values(data)
  data=encode_data(data)
  return data

# call outliers and balance function independentlu whenever you like and PS Fuck Roopa

def reduced_Dataset(data,reduction:int,method:str='PCA'):
  if method == 'PCA':
    return PCA(data,reduction)
 
  elif method == 'Kernel':
    return KernelPCA(data,reduction)

#go with pca since kernel pca might take quite  a long time
  


def PCA(data,reduction):
  from sklearn.decomposition import PCA
  pca=PCA(n_components=reduction)#n_component=reduced dimension of dataset
  reduced_data=pca.fit_transform(data)
  return reduced_data

def KernelPCA(data,reduction):
  from sklearn.decomposition import KernelPCA
  pca=KernelPCA(n_components=reduction,kernel='rbf')
  reduced_data=pca.fit_transform(data)
  return reduced_data

data1 = preprocess_data(data1)

data2 = preprocess_data(data2)

data3 = preprocess_data(data3)

data4 = preprocess_data(data4)

#reducing the preprocessed data
#reducing the dimension is a good idea sice some of the clustering algo requires heavy computation and therefore will most
#probably run out of resources
data1 = reduced_Dataset(data1,10)
data2 = reduced_Dataset(data2,10)

#not reducing dataset since they are of low dimensions
#data3 = reduced_Dataset(data3,10)
#data4 = reduced_Dataset(data4,20)

#these are the new dimensions of our data now
data1.shape

data2.shape

data3.shape

data4=pd.read_csv('/content/CC GENERAL.csv')
data4

#since custId is not so related to our problem statement therefore removing this field 
# but will use it later as one of the parametres in the 2d Axis
data4.drop(['CUST_ID'], axis = 1, inplace = True)

#preproecessing the dataset with the cust_id column removd
data4=preprocess_data(data4)

#this is the preprocessed dataset
data4

#k-mean clustering

#radom initializtion trap is taken care of automatically since the algoo implemented is k-means++
def kmeansClustering(data,nClusters):
  from sklearn.cluster import KMeans
  kmeans = KMeans(n_clusters = nClusters, init = 'k-means++', random_state = 42)
  y_kmeans = kmeans.fit_predict(data)
  return y_kmeans
  

def elbowMethod(data,min:int=2,max:int=20):
  from sklearn.cluster import KMeans
  wcss = []#within cluster sum of squares we use this matrice to define the effciecy of model foer k number of clusters
  for i in range(1, 11):
    kmeans = KMeans(n_clusters = i, init = 'k-means++', random_state = 42)
    kmeans.fit(data)
    wcss.append(kmeans.inertia_)
  plt.plot(range(1, 11), wcss)
  plt.title('The Elbow Method')
  plt.xlabel('Number of clusters')
  plt.ylabel('WCSS')
  plt.show()

elbowMethod(data1)
#looking at the plot we can deduce that 3 is the idol choice for number of clusters we can alson try with 4

elbowMethod(data2)
#looking at the plot we can deduce that 3 is the idol choice for number of clusters we can alson try with 4

elbowMethod(data3)

elbowMethod(data4)

kmeans_data1 = kmeansClustering(data1,2)

kmeans_data2 = kmeansClustering(data2,2)

kmeans_data3 = kmeansClustering(data3,3)

kmeans_data4 = kmeansClustering(data4,3),3#since 3 is the optimal value from the elbow method

#implementing bisecting k-means cluster
# yet to find the implementation

#Hierarchial clustering
def HierarchialClustering(data,nClusters:int,affinity:str='euclidean',linkage:str='ward'):
  from sklearn.cluster import AgglomerativeClustering
  hc = AgglomerativeClustering(n_clusters = nClusters, affinity = affinity, linkage = linkage)
  y_hc = hc.fit_predict(data)
  return y_hc
def createDendogram(data):
  import scipy.cluster.hierarchy as sch
  dendrogram = sch.dendrogram(sch.linkage(data, method = 'ward'))
  # ward is the clusering techniique best suited for hierarchial clustering




  # ward stands for minimum variance
  plt.title('Dendrogram')
  plt.ylabel('Euclidean distances')
  plt.show()

createDendogram(data1)
#in this the optimal number is 2

createDendogram(data2)
#in this cluster the optimal number is 2

createDendogram(data3)#optimal number of clusters in this case was 3

createDendogram(data4)#optimal number of clusters in this case was 3

hierarchialData1 = HierarchialClustering(data1,2) #since 3 is the optimal number of clusters from the dendogram

hierarchialData2 = HierarchialClustering(data2,2)#since 3 is the optimal number of clusters from the dendogram

hierarchialData3 = HierarchialClustering(data3,3)#since 3 is the optimal number of clusters from the dendogram

hierarchialData4 = HierarchialClustering(data4,3)#since 3 is the optimal number of clusters from the dendogram

#Mean shift clustering
#note this algorithm is quite clumsy for large datasets
#finding the optimal value of the bandwidth => this will be tackled by the second function
#this requires heavy computational resources so either reduce the dataset first or run it in jupyter notebook
def meanShiftClustering(data):
  from sklearn.cluster import MeanShift
  bandwidth = bandwidthDetermination(data)#this function will give you the otimal value for the bandwidth
  clustering = MeanShift(n_jobs=-1,bandwidth=bandwidth)
  cluster = clustering.fit_predict(data) #this algo will be clumsy for a large dataset
  #runnig time is O(n2)
  return cluster


#this function will return the bandwidth value that will be used in the above function
def bandwidthDetermination(data):
  from sklearn.cluster import estimate_bandwidth
  bandwidth = estimate_bandwidth(data)#for large datasets this will take some time
  return bandwidth

meanShiftData1 = meanShiftClustering(data1)
meanShiftData2 = meanShiftClustering(data2)
meanShiftData3 = meanShiftClustering(data3)
meanShiftData4 = meanShiftClustering(data4)

"""#This is basicallyy a hybrid of kmeans and hierrarchial clustering

> Indented block

> Indented block

> Indented block






#ANd it is computationaly more efficient than regulat kmeans

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAn4AAAJ5CAYAAAAw1T3YAAAgAElEQVR4Aey9DZRW1Znv2auzzB0z19zEJMAtAVFEguINtthFgVKKUEBVqRSIWChiN9IoMMGgYEBtmqtgxsBAMLRAonWNWiqgSRErfChdGlKrQVQ6RLsHknUd0+NHEtMfsWe65/ZMnln/t2pX7ffU+djnfc/HPuf8a613nffj1Dn77P3fz/nt59n7OX9QN2ia8MU6oAaoAWqAGqAGqAFqIP8a+AM2cv4bmW3MNqYGqAFqgBqgBqgBaIDgR48nPb7UADVADVAD1AA1UBANEPwK0tAc6XGkRw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1UBANEPwK0tAc5XGURw1QA9QANUANUAMEP4IfR3nUADVADVAD1AA1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)
"""

#there is not a stable implementation of this algo in sklearn yet
#so we will be implementing it using pyspark
!pip install pyspark

#maa chudae bc ye model
def  bisectingKmeans(data,nClusters:int):
  from pyspark.ml.clustering import BisectingKMeans
  from pyspark.ml.evaluation import ClusteringEvaluator
  #training the model
  bkm = BisectingKMeans().setK(nClusters).setSeed(1)#seed param?
  model = bkm.fit(data)
  # Make predictions
  predictions = model.transform(data)

  # Evaluate clustering by computing Silhouette score
  evaluator = ClusteringEvaluator()

  silhouette = evaluator.evaluate(predictions)
  print("Silhouette with squared euclidean distance = " + str(silhouette))
  # Shows the result.
  print("Cluster Centers: ")
  centers = model.clusterCenters()
  for center in centers:
    print(center)

#data bases spatial clustering of application with noise
#as the name suggest this model will work well on a noisy dataset
#DBSCAN 
def DBSCAN(data,epsillon:int,nNumber:int):
  from sklearn.cluster import DBSCAN
  clustering = DBSCAN(eps=epsillon,min_samples=nNumber)
  cluster = clustering.fit_predict(data)
  return cluster
  #how to plot it now?


#this function will generate the min number of points
def giveMinPoints(data):
  dimension=data.shape[1]
  # call the epsillon function as well in the first two conditions
  if dimension == 2:
    giveEpsillon(data,4)
    print(f"The min number of points {4}")
    return 4
  elif dimension > 2:
    giveEpsillon(data,2*dimension)
    return 2*dimension
    print(f'The min number of points {2*dimension}')
  else:
    return -1

#this function will generate epsillon
#this function is not sure to give best results since for large dataset the plot is not so clear
def giveEpsillon(data,neighbours:int):
  from sklearn.neighbors import NearestNeighbors
  neighbors = NearestNeighbors(n_neighbors=neighbours)
  neighbors_fit = neighbors.fit(data)
  distances, indices = neighbors_fit.kneighbors(data)
  distances = np.sort(distances, axis=0)
  distances = distances[:,1]
  plt.plot(distances)
  #make this more flexible for large datasets

giveMinPoints(data1) #looking the graph the ideal epsilon value for data 2 is around 70
#as we can see in this graph there is a wide range of values that can be used as epsilon
#so in case of large dataset concluding epsilon value using this technique is not a good idea
#I guess
#so in this case the ideal epsilon value can range from 0 to 2000
#based on rule of thumb we should use 20 as min points but that does not make
#sense in a dataset with around 19k observations we shoulfd probably
#go with a higher value and than based on trial and error find the optimal
#value for the dataset

giveMinPoints(data2) #looking the graph the ideal epsilon value for data 2 is around 70
#for this smaller dataset we can deduce the epsilon value by looking at the graph
#epsilon is the corresponding point to the most curvature point
#so in this case epsilon is around 70
#looing at this dataset since it has only 150 observations we can use
#20 as min number of points

giveMinPoints(data3)#the epsilon value works okish in low dimension datasets but not so good / rather horrible for high dimension dataset

giveMinPoints(data4)

dbscanData2=DBSCAN(data2,70,20)

dbscanData1=DBSCAN(data1,2000,4500)#yaar is there a way to find the optimal value of epsilon

for val in dbscanData2:
  if val != -1:
    print(val)

"""Based on above observations we can conclude that finding the hyperparamtres of epsilon and min points for DBSCAN is easy in case of small dataset using these techniques but in case of large dataset we need to go with trial and error if one in thinking of implementing this model

# Min number of sample points

Minimum Samples (“MinPts”)
There is no automatic way to determine the MinPts value for DBSCAN. Ultimately, the MinPts value should be set using domain knowledge and familiarity with the data set. From some research I’ve done, here are a few rules of thumb for selecting the MinPts value:

1)The larger the data set, the larger the value of MinPts should be

2)If the data set is noisier, choose a larger value of MinPts
Generally, MinPts should be greater than or equal to the dimensionality of the data set

3)For 2-dimensional data, use DBSCAN’s default value of MinPts = 4 (Ester et al., 1996).

4)If your data has more than 2 dimensions, choose MinPts = 2*dim, where dim= the dimensions of your data set (Sander et al., 1998).

#Epsilon value
After you select your MinPts value, you can move on to determining ε. One technique to automatically determine the optimal ε value is described in this paper. This technique calculates the average distance between each point and its k nearest neighbors, where k = the MinPts value you selected. The average k-distances are then plotted in ascending order on a k-distance graph. You’ll find the optimal value for ε at the point of maximum curvature (i.e. where the graph has the greatest slope).
"""

#fuzzy c-mean clustering
#this is a more complex algo
#fuzzy partitio  is used and based on that fuzzy partition
#an equation is derived and our task is to minimize
#some variable in that equation

#minibatch kmeans algorithm
#we basically break the large dataset into small batches
# so that they can be allocated in memmory where as a large dataset can not be allocated into the memmory

def minBatchKmeans(data,nClusters:int,batchSize:int=10,max_iter:int=10):
  from sklearn.cluster import MiniBatchKMeans
  clustering = MiniBatchKMeans(n_clusters=nClusters,batch_size=batchSize,max_iter=max_iter,random_state=42)
  cluster=clustering.fit_predict(data)
  return cluster

minBatchData1=minBatchKmeans(data1,2)

minBatchData2=minBatchKmeans(data2,2)

minBatchData3 = minBatchKmeans(data3,3)

minBatchData4 = minBatchKmeans(data4,3)

#affinity propogation
#clusters are formed by passing in messages between the data points
#this will probably run out of resources
def affinityPropogation(data):
  from sklearn.cluster import AffinityPropagation
  clustering=AffinityPropagation()
  cluster = clustering.fit_predict(data)
  return cluster

"""# This method consumes high resources therefore run it in local machine where you can allocate the sources"""

affinityData1 = affinityPropogation(data1)
#it requires more resources for large dataset and will eventually run out of resources

affinityData2 = affinityPropogation(data2)

affinityData3 = affinityPropogation(data3)

"""# This algo works on graph data i.e the data should be connected and therefore will not work on normal data that is not connected"""

#spectral
#we need to specify the number of ckusters in this case
#this algorithm has a lot of hyperparametres that we can optimize
#this algorithm can only be used with connected/graphed data so don't use it with
#normal data since normal dataset is not connected
def spectralClustering(data,nClusters:int=2):
  from sklearn.cluster import SpectralClustering
  clustering = SpectralClustering(n_clusters=nClusters,random_state=42,n_jobs=-1)
  cluster = clustering.fit_predict(data)
  return cluster

spectralData1 = spectralClustering(data4)
#gives error of fully connected database

#gaussian mixture models
#thia model can cluster non spherical data and it also
#it's always a good idea to reduce the dataset as it reduces the red flag variables in our dataset
def GMMClustering(data,nComponents:int=2):
  from sklearn.mixture import GaussianMixture
  clustering = GaussianMixture(n_components=nComponents,random_state=42)
  cluster = clustering.fit_predict(data)
  return cluster

GMMData1 = GMMClustering(data1)
GMMData2 = GMMClustering(data2)
GMMData3 = GMMClustering(data3)
GMMData4 = GMMClustering(data4)

#optics clustering model
#this too requires epsilon value so fuck this model
def opticsClustering(data,epsilon):
  from sklearn.cluster import OPTICS, cluster_optics_dbscan
  minSamples = giveMinPoints(data)
  optics_model = OPTICS(min_samples = minSamples)
  optics_model.fit(data)  
   # Producing the labels according to the DBSCAN technique 
  labels = cluster_optics_dbscan(reachability = optics_model.reachability_,
                                   core_distances = optics_model.core_distances_,
                                   ordering = optics_model.ordering_, eps = epsilon)

  labels = optics_model.labels_[optics_model.ordering_]  
  return labels

opticsData1 = opticsClustering(data1,2000)#this value of epsilon is giving false results so go with trial and error
#yaar isn't there any way of finding the optimal value for epsilon
opticsData2 = opticsClustering(data2,70)

def birchAlgo(data,nClusters:int=3):
  from sklearn.cluster import Birch
  clustering = Birch(n_clusters = nClusters)#ooh ma good turu lobh
  cluster = clustering.fit_predict(data)
  return cluster


birchData1 = birchAlgo(data1)
birchData2 = birchAlgo(data2)
birchData3 = birchAlgo(data3)
birchData4 = birchAlgo(data4)

!pip install hdbscan

#last clustering algo finish it then proceed with visualization
#  It extends DBSCAN by converting it into a hierarchical clustering algorithm, 
#  and then using a technique to extract a flat clustering based in the stability of clusters.
def HDBCANClustering(data):
  import hdbscan 
  clustering = hdbscan.HDBSCAN()
  cluster = clustering.fit(data)
  return cluster.labels_
#yaar isn't there any way for finding the optimal value for epsilon
HDBSCANData1=HDBCANClustering(data1)
HDBSCANData2=HDBCANClustering(data2)

"""#Note use these algo only of you know the idol value for epsilong and min number of points
#these algos are good but if you don't know the idol value for epsilon
# dont use these models

#1)DBSCAN

#2)OPTICS

#3)HDBSCAN

#in this section excluding dbscan realted models since the idol value of espilon value is not found yet for the larger dataset i.e airplane dataset
"""

#visualizing the clusters
#for cluster visualiztion we need to reduce our data to two independet data points
#we are creating new dataframes

newKmeans1 = pd.read_csv('/content/Air_Traffic_Passenger_Statistics.csv')
newKmeans2 = pd.read_csv('/content/total_data_na.csv')
newKmeans3 = pd.read_csv('/content/Mall_Customers.csv')
newKmeans4 = pd.read_csv('/content/CC GENERAL.csv')
newHierarchial1 =  pd.read_csv('/content/Air_Traffic_Passenger_Statistics.csv')
newHierarchial2 =  pd.read_csv('/content/total_data_na.csv')
newHierarchial3 = pd.read_csv('/content/Mall_Customers.csv')
newHierarchial4 = pd.read_csv('/content/CC GENERAL.csv')
newMeanShift1 =  pd.read_csv('/content/Air_Traffic_Passenger_Statistics.csv')
newMeanShift2 =  pd.read_csv('/content/total_data_na.csv')
newMeanShift3 = pd.read_csv('/content/Mall_Customers.csv')
newMeanShift4 = pd.read_csv('/content/CC GENERAL.csv')
newMinBatchk1 =  pd.read_csv('/content/Air_Traffic_Passenger_Statistics.csv')
newMinBatchk2 =  pd.read_csv('/content/total_data_na.csv')
newMinBatchk3 = pd.read_csv('/content/Mall_Customers.csv')
newMinBatchk4 = pd.read_csv('/content/CC GENERAL.csv')
newBirch1 =  pd.read_csv('/content/Air_Traffic_Passenger_Statistics.csv')
newBirch2 =  pd.read_csv('/content/total_data_na.csv')
newBirch3 = pd.read_csv('/content/Mall_Customers.csv')
newBirch4 = pd.read_csv('/content/CC GENERAL.csv')
newKmeans1.insert(newKmeans1.shape[1],'Cluster',kmeans_data1)  #here we are inserting the clusters column as the last field of the dataset
newKmeans2.insert(newKmeans2.shape[1],'Cluster',kmeans_data2)
newKmeans3.insert(newKmeans3.shape[1],'Cluster',kmeans_data3)
#newKmeans4.insert(newKmeans4.shape[1],'Cluster',kmeans_data4)
newHierarchial1.insert(newHierarchial1.shape[1],'Cluster',hierarchialData1)
newHierarchial2.insert(newHierarchial2.shape[1],'Cluster',hierarchialData2)
newHierarchial3.insert(newHierarchial3.shape[1],'Cluster',hierarchialData3)
newHierarchial4.insert(newHierarchial4.shape[1],'Cluster',hierarchialData4)
newMeanShift1.insert(newMeanShift1.shape[1],'Cluster',meanShiftData1)
newMeanShift2.insert(newMeanShift2.shape[1],'Cluster',meanShiftData2)
newMeanShift3.insert(newMeanShift3.shape[1],'Cluster',meanShiftData3)
newMeanShift4.insert(newMeanShift4.shape[1],'Cluster',meanShiftData4)
#newMinBatchk1.insert(newMinBatchk1.shape[1],'Cluster',minBatchData1)
#newMinBatchk2.insert(newMinBatchk2.shape[1],'Cluster',minBatchData2)
newMinBatchk3.insert(newMinBatchk3.shape[1],'Cluster',minBatchData3)
newMinBatchk4.insert(newMinBatchk4.shape[1],'Cluster',minBatchData4)
newBirch1.insert(newBirch1.shape[1],'Cluster',birchData1)
newBirch2.insert(newBirch2.shape[1],'Cluster',birchData2)
newBirch3.insert(newBirch3.shape[1],'Cluster',birchData3)
newBirch4.insert(newBirch4.shape[1],'Cluster',birchData4)

#in this section you can generate a new dataframe of dimension Nx3 to visualize the clusters
#the thing with  this is that some of the columns do not participate in cluster formation and some do since we applies dimensionality reduction
def generateDataframe(data,feature1,feature2):
  #generating new dataset
  feature1Data = data[feature1]
  feature2Data = data[feature2]
  cluster = data['Cluster']

  index=[]
  for i in range(0,data.shape[0]):
    index.append(i)

  columns = [feature1,feature2,'Cluster']


  data = []
  for feat1,feat2,label in zip(feature1Data,feature2Data,cluster):
    data.append([feat1,feat2,label])

  newData=pd.DataFrame(data=data,index=index,columns=columns)
  return newData

print('THis is the columns available in the first dataset1:')
for column in newBirch1.columns:
  print(column)

print('THis is the columns available in the second dataset1:')
for column in newBirch2.columns:
  print(column)

print('THis is the columns available in the second dataset1:')
for column in newBirch3.columns:
  print(column)

print('THis is the columns available in the second dataset1:')
for column in newBirch4.columns:
  print(column)

#this is the visualization dataset

#kmeans dataseet
Kmeans1=generateDataframe(newKmeans1,'Operating Airline','Passenger Count')
Kmeans2=generateDataframe(newKmeans2,'Inns.x','Avg.x')
Kmeans3=generateDataframe(newKmeans3,'Genre','Age')
#Kmeans4=generateDataframe(newKmeans4,'BALANCE','PURCHASES')
#hierarchial dataset
Hierarchial1=generateDataframe(newHierarchial1,'Operating Airline','Passenger Count')
Hierarchial2=generateDataframe(newHierarchial2,'Inns.x','Avg.x')
Hierarchial3=generateDataframe(newHierarchial3,'Genre','Age')
Hierarchial4=generateDataframe(newHierarchial4,'BALANCE','PURCHASES')

#min batch dataset
MinBatch1=generateDataframe(newMeanShift1,'Operating Airline','Passenger Count')
MinBatch2=generateDataframe(newMeanShift2,'Inns.x','Avg.x')
MinBatch3=generateDataframe(newMeanShift3,'Genre','Age')
MinBatch4=generateDataframe(newMeanShift4,'BALANCE','PURCHASES')

#meanShift dataset
#meanShift1=generateDataframe(newMinBatchk1,'GEO Region','Price Category Code')
#meanShift2=generateDataframe(newMinBatchk2,'Inns.x','Avg.x')

#birch dataset
Birch1=generateDataframe(newBirch1,'Operating Airline','Passenger Count')
Birch2=generateDataframe(newBirch2,'Inns.x','Avg.x')
Birch3=generateDataframe(newBirch3,'Genre','Age')
Birch4=generateDataframe(newBirch4,'BALANCE','PURCHASES')

#creating the new dataframe with only three features one being the cluster itself

#these are all the colors which we will use to represent the clusters

colors = ['red','blue','magenta','green','cadetblue','chartreuse',
          'chocolate','coral','cornflowerblue','cornsilk','crimson',
          'cyan','darkblue','darkcyan','darkgoldenrod','darkgray'
          ,'dodgerblue','firebrick','floralwhite','forestgreen',
          'fuchsia','gainsboro','ghostwhite','gold','goldenrod','gray','greenyellow',
          'honeydew','hotpink','linen',
          'maroon','mediumaquamarine','olivedrab','tan','teal','thistle','tomato','turquoise','violet',
          'wheat','white','whitesmoke','yellowgreen''antiquewhite','aqua','aquamarine',
          'azure','beige','bisque','black','blanchedalmond',
          'blueviolet','brown','burlywood','indianred',
          'mintcream','mistyrose','moccasin','navajowhite','navy','oldlace','olive','darkmagenta','darkolivegreen',
          'darkorange','darkorchid','indigo','ivory','khaki','lavender','lavenderblush',
          'lawngreen','lemonchiffon','lightblue','lightcoral','darkgreen','darkturquoise','darkviolet','deeppink'
          ,'deepskyblue','dimgray','lightcyan','lightgoldenrodyellow',
          'lightgreen','lightgray','lightpink','lightsalmon','lightseagreen','lightskyblue',
          'lightslategray','lightsteelblue','lightyellow','lime','limegreen',
          'orange','orangered','orchid','palegoldenrod','palegreen','paleturquoise','palevioletred',
          'papayawhip','peachpuff','peru','pink','plum','powderblue','purple','aliceblue','rosybrown','royalblue',
          'saddlebrown','salmon','sandybrown','seagreen','seashell','sienna','silver','skyblue','slateblue',
          'slategray','snow','springgreen','steelblue','yellow',]

"""# IN this section we will be visualizing the clusters using two features and one label column we will polt a 2d visulization of the clusters """

#visualizing our created cluserts by using newly created dataframes with only three features two for axis and one being the cluster column itself

def createClusterVisualization(data): #this function expects our newly created dataframe of type NX3
  xAxis = data.columns[0] #this is our first feature with highest correlation
  yAxis = data.columns[1]# this is our second feature with second highest correlation
  numClusters = data['Cluster'].nunique()
  plt.figure(figsize=(20,10))
  for i in range (0,numClusters):
    x=[]
    y=[]
    for index,row in data.iterrows():
      if row['Cluster'] == i:
        x.append(row[xAxis])
        y.append(row[yAxis])
    plt.scatter(x,y, s = 100, c = colors[i], label = f'Cluster {i}')
  plt.title('Clusters formed')
  plt.xlabel(xAxis) 
  plt.ylabel(yAxis)
  plt.legend()
  plt.show()

  #need to add centriods of clusters as well




# plt.scatter(X[y_kmeans == 0, 0], X[y_kmeans == 0, 1], s = 100, c = 'red', label = 'Cluster 1')
# plt.scatter(X[y_kmeans == 1, 0], X[y_kmeans == 1, 1], s = 100, c = 'blue', label = 'Cluster 2')
# plt.scatter(X[y_kmeans == 2, 0], X[y_kmeans == 2, 1], s = 100, c = 'green', label = 'Cluster 3')
# plt.scatter(X[y_kmeans == 3, 0], X[y_kmeans == 3, 1], s = 100, c = 'cyan', label = 'Cluster 4')
# plt.scatter(X[y_kmeans == 4, 0], X[y_kmeans == 4, 1], s = 100, c = 'magenta', label = 'Cluster 5')
# plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], s = 300, c = 'yellow', label = 'Centroids')
# plt.title('Clusters of customers')
# plt.xlabel('Annual Income (k$)')
# plt.ylabel('Spending Score (1-100)')
# plt.legend()
# plt.show()

createClusterVisualization(Kmeans1)

createClusterVisualization(Kmeans2)

createClusterVisualization(Kmeans3)

createClusterVisualization(Hierarchial1)

createClusterVisualization(Hierarchial2)

createClusterVisualization(Hierarchial3)

createClusterVisualization(Hierarchial4)

createClusterVisualization(MinBatch1)

createClusterVisualization(MinBatch2)

createClusterVisualization(MinBatch3)

createClusterVisualization(Birch1)

createClusterVisualization(Birch2)

createClusterVisualization(Birch3)

createClusterVisualization(Birch4)

"""# This section deals with the hyperparametre optimization of the models
#to be contiuned study all the models again

#This section is used for model evaluation and how well our model clusterd the given datasets based on 

#These are the two matrices for clustering model evaluation

#1)Silhouette Coefficient:
The Silhouette Coefficient is defined for each sample and is composed of two scores:
a: The mean distance between a sample and all other points in the same cluster.
b: The mean distance between a sample and all other points in the next nearest cluster.

The Silhouette Coefficient for a set of samples is given as the mean of the Silhouette Coefficient for each sample. The score is bounded between -1 for incorrect clustering and +1 for highly dense clustering. Scores around zero indicate overlapping clusters. **The score is higher when clusters are dense and well separated, which relates to a standard concept of a cluster.**

#2)Dunn’s Index:
Dunn’s Index (DI) is another metric for evaluating a clustering algorithm. Dunn’s Index is equal to the minimum inter-cluster distance divided by the maximum cluster size. Note that large inter-cluster distances (better separation) and smaller cluster sizes (more compact clusters) lead to a higher DI value.

**A higher DI implies better clustering. It assumes that better clustering means that clusters are compact and well-separated from other clusters.**
"""

#evaluating models based on silhoute coefficient

#evaluating models based on the Dunn coefficient